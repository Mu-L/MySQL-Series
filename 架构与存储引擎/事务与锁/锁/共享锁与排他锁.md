# 共享锁与排他锁

从锁的策略上来看，InnoDB 还实现了共享锁（S）与排他锁（X)。

- 共享锁（S）：共享锁允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁；
- 排他锁（X)：排他锁则允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。

Innodb 引擎中，对于 insert、update、delete，InnoDB 会自动给涉及的数据加排他锁（X）；对于一般的 Select 语句，InnoDB 不会加任何锁。事务可以通过以下语句给显示加共享锁或排他锁：

```sql
SELECT ... LOCK IN SHARE MODE; -- 共享锁
SELECT ... FOR UPDATE; -- 排他锁
```

另外，为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁。

- 意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。
- 意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。

```sql
mysql> set autocommit = 0;

/* 共享锁 */
-- 当前 session 对 actor_id=178 的记录加 share mode 的共享锁：
mysql> select actor_id,first_name,last_name from actor where actor_id = 178 lock in share mode;

-- 当前session对锁定的记录进行更新操作，等待锁：
mysql> update actor set last_name = 'MONROE T' where actor_id = 178;

-- 其他session仍然可以查询记录，并也可以对该记录加share mode的共享锁：
mysql> select actor_id,first_name,last_name from actor where actor_id = 178lock in share mode;

-- 其他session也对该记录进行更新操作，则会导致死锁退出：
mysql> update actor set last_name = 'MONROE T' where actor_id = 178;
-- ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction

-- 获得锁后，可以成功更新：
-- Query OK, 1 row affected (17.67 sec)

/* 排他锁 */
-- 当前session对actor_id=178的记录加for update的排它锁：
mysql> select actor_id,first_name,last_name from actor where actor_id = 178 for update;

-- 其他session可以查询该记录，但是不能对该记录加共享锁，会等待获得锁：
mysql> select actor_id,first_name,last_name from actor where actor_id = 178 for update;

-- 当前session可以对锁定的记录进行更新操作，更新后释放锁：
mysql> update actor set last_name = 'MONROE T' where actor_id = 178;
mysql> commit;

-- 其他session获得锁，得到其他session提交的记录：
mysql> select actor_id,first_name,last_name from actor where actor_id = 178 for update;
```

值得一提的是，普通的查询操作都是非锁定读，会基于 MVCC 来实现多版本并发控制。如果存在事务冲突，会利用 Undo Log 获取新事务操作之前的镜像返回，在读已提交的隔离级别下，会获取新事务修改前的最新的一份已经提交的数据，而在可重复读的隔离级别下，会读取该事务开始时的数据版本。当有多个事务并发操作同一行记录时，该记录会同时存在多个 Undo Log。

而加锁之后就变成了锁定读，所有的锁定读都是当前读，也就是读取当前记录的最新版本，不会利用 Undo Log 读取镜像。另外所有的 insert、update、delete 操作也是当前读，update、delete 会在更新之前进行一次当前读，然后加锁，而 insert 因为会触发唯一索引检测，也会包含一个当前读。

# 间隙锁

当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB 会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做间隙（GAP)，InnoDB 也会对这个间隙加锁，这种锁机制就是所谓的间隙锁（Next-Key 锁）。

举例来说，假如 emp 表中只有 101 条记录，其 empid 的值分别是 1,2,...,100,101，`mysql> select * from emp where empid > 100 for update;`就是一个范围条件的检索，InnoDB 不仅会对符合条件的 empid 值为 101 的记录加锁，也会对 empid 大于 101 这些记录并不存在的间隙加锁。

InnoDB 使用间隙锁的目的，一方面是为了防止幻读，以满足相关隔离级别的要求，对于上面的例子，要是不使用间隙锁，如果其他事务插入了 empid 大于 100 的任何记录，那么本事务如果再次执行上述语句，就会发生幻读；另外一方面，是为了满足其恢复和复制的需要。有关其恢复和复制对锁机制的影响，以及不同隔离级别下 InnoDB 使用间隙锁的情况，在后续的章节中会做进一步介绍。

很显然，在使用范围条件检索并锁定记录时，InnoDB 这种加锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待。因此，在实际应用开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。还要特别说明的是，InnoDB 除了通过范围条件加锁时使用间隙锁外，如果使用相等条件请求给一个不存在的记录加锁，InnoDB 也会使用间隙锁。

```sql
--- 当前session对不存在的记录加for update的锁：
mysql> select * from emp where empid = 102 for update;

--- 这时，如果其他session插入empid为102的记录（注意：这条记录并不存在），也会出现锁等待：
mysql>insert into emp(empid,...) values(102,...);

--- session 1 执行 rollback：
mysql> rollback;

--- 由于其他session_1回退后释放了Next-Key锁，当前session可以获得锁并成功插入记录：
mysql>insert into emp(empid,...) values(102,...);
```
